syntax = "proto3";

package navarch;

import "google/protobuf/timestamp.proto";

option go_package = "github.com/NavarchProject/navarch/proto";

// ControlPlaneService is the main control plane API.
// Serves both node daemons (for registration, heartbeats, health) and operators (for management, commands).
// Access control and authentication are enforced at the API layer.
service ControlPlaneService {
  // ===============================
  // Node operations (called by node daemons)
  // ===============================

  // RegisterNode registers a new node with the control plane.
  // Called once during node bootstrap to establish identity and capabilities.
  rpc RegisterNode(RegisterNodeRequest) returns (RegisterNodeResponse);

  // ReportHealth sends health check results from a node to the control plane.
  // Nodes call this after running health checks (boot, nvml, xid, etc).
  rpc ReportHealth(ReportHealthRequest) returns (ReportHealthResponse);

  // SendHeartbeat sends periodic keepalive signals from the node.
  // Used to detect node failures and maintain connection state.
  rpc SendHeartbeat(HeartbeatRequest) returns (HeartbeatResponse);

  // GetNodeCommands polls for commands from the control plane.
  // Returns actions like cordon, drain, or diagnostic requests.
  rpc GetNodeCommands(GetNodeCommandsRequest) returns (GetNodeCommandsResponse);

  // ===============================
  // Admin operations (called by CLI, API, operators)
  // ===============================

  // ListNodes returns all registered nodes with their current status.
  rpc ListNodes(ListNodesRequest) returns (ListNodesResponse);

  // GetNode returns details about a specific node.
  rpc GetNode(GetNodeRequest) returns (GetNodeResponse);

  // IssueCommand issues a command to a specific node.
  // The node will receive this command on its next GetNodeCommands poll.
  rpc IssueCommand(IssueCommandRequest) returns (IssueCommandResponse);

  // ===============================
  // Instance operations (cloud resource tracking)
  // ===============================

  // ListInstances returns all tracked instances with their current state.
  // Instances are tracked from provisioning through termination.
  rpc ListInstances(ListInstancesRequest) returns (ListInstancesResponse);

  // GetInstance returns details about a specific instance.
  rpc GetInstance(GetInstanceRequest) returns (GetInstanceResponse);
}

message RegisterNodeRequest {
  // Unique identifier for this node (typically instance ID from cloud provider).
  string node_id = 1;

  // Cloud provider name (e.g., "gcp", "aws", "azure").
  string provider = 2;

  // Cloud region where the node is running.
  string region = 3;

  // Availability zone within the region.
  string zone = 4;

  // Instance type (e.g., "a3-highgpu-8g", "p5.48xlarge").
  string instance_type = 5;

  // List of GPUs detected on this node.
  repeated GPUInfo gpus = 6;

  // Additional node metadata.
  NodeMetadata metadata = 7;
}

message RegisterNodeResponse {
  // Whether registration was successful.
  bool success = 1;

  // Human-readable message (error details if success=false).
  string message = 2;

  // Configuration parameters the node should use.
  NodeConfig config = 3;
}

// GPUInfo describes a single GPU device on a node.
message GPUInfo {
  // GPU index on the node (0-based).
  int32 index = 1;

  // GPU UUID from nvidia-smi.
  string uuid = 2;

  // GPU model name (e.g., "NVIDIA H100 80GB HBM3").
  string name = 3;

  // PCI bus ID (e.g., "0000:00:04.0").
  string pci_bus_id = 4;

  // Total GPU memory in bytes.
  int64 memory_total = 5;

  // NVIDIA driver version.
  string driver_version = 6;

  // CUDA version.
  string cuda_version = 7;
}

// NodeMetadata contains system information about a node.
message NodeMetadata {
  // System hostname.
  string hostname = 1;

  // Internal/private IP address.
  string internal_ip = 2;

  // External/public IP address (if any).
  string external_ip = 3;

  // Linux kernel version.
  string kernel_version = 4;

  // User-defined labels for organization and filtering.
  map<string, string> labels = 5;
}

// NodeConfig contains configuration parameters sent from control plane to node.
message NodeConfig {
  // How often to run periodic health checks (in seconds).
  int32 health_check_interval_seconds = 1;

  // How often to send heartbeat messages (in seconds).
  int32 heartbeat_interval_seconds = 2;

  // Which health checks to enable (e.g., ["nvml", "xid", "boot"]).
  repeated string enabled_health_checks = 3;
}

message ReportHealthRequest {
  // ID of the node reporting health.
  string node_id = 1;

  // List of health check results (legacy format).
  repeated HealthCheckResult results = 2;

  // Raw health events for CEL policy evaluation (new format).
  // When present, the control plane evaluates these against the configured
  // health policy to determine node health status.
  repeated HealthEvent events = 3;
}

message ReportHealthResponse {
  // Whether the report was received and processed.
  bool acknowledged = 1;

  // Overall node status as determined by the control plane.
  NodeStatus node_status = 2;
}

// HealthCheckResult represents the outcome of a single health check.
message HealthCheckResult {
  // Name of the health check that ran (e.g., "nvml", "xid", "boot").
  string check_name = 1;

  // Overall status of this check.
  HealthStatus status = 2;

  // Human-readable message describing the result.
  string message = 3;

  // When this check completed.
  google.protobuf.Timestamp timestamp = 4;

  // Additional diagnostic information (check-specific details).
  map<string, string> details = 5;
}

// HealthStatus indicates the result of a health check.
enum HealthStatus {
  // Unknown or uninitialized status.
  HEALTH_STATUS_UNKNOWN = 0;

  // Health check passed, no issues detected.
  HEALTH_STATUS_HEALTHY = 1;

  // Health check found minor issues (warnings, but still functional).
  HEALTH_STATUS_DEGRADED = 2;

  // Health check failed, node should not accept workloads.
  HEALTH_STATUS_UNHEALTHY = 3;
}

// HealthEventType categorizes GPU health events.
// See https://docs.nvidia.com/deploy/xid-errors/index.html for XID documentation.
enum HealthEventType {
  HEALTH_EVENT_TYPE_UNKNOWN = 0;

  // XID error from NVIDIA GPU driver.
  HEALTH_EVENT_TYPE_XID = 1;

  // Thermal event (temperature warning or critical).
  HEALTH_EVENT_TYPE_THERMAL = 2;

  // Power event (power limit, power brake, etc).
  HEALTH_EVENT_TYPE_POWER = 3;

  // Memory event (general memory issues).
  HEALTH_EVENT_TYPE_MEMORY = 4;

  // NVLink error (multi-GPU communication).
  HEALTH_EVENT_TYPE_NVLINK = 5;

  // PCIe error (host-GPU communication).
  HEALTH_EVENT_TYPE_PCIE = 6;

  // Driver error (NVML, DCGM failures).
  HEALTH_EVENT_TYPE_DRIVER_ERROR = 7;

  // Single-bit ECC error (correctable).
  HEALTH_EVENT_TYPE_ECC_SBE = 8;

  // Double-bit ECC error (uncorrectable).
  HEALTH_EVENT_TYPE_ECC_DBE = 9;
}

// HealthWatchSystem identifies the DCGM health watch system that generated an event.
// See https://docs.nvidia.com/datacenter/dcgm/latest/user-guide/feature-overview.html#health
enum HealthWatchSystem {
  HEALTH_WATCH_SYSTEM_UNKNOWN = 0;
  HEALTH_WATCH_SYSTEM_PCIE = 1;
  HEALTH_WATCH_SYSTEM_NVLINK = 2;
  HEALTH_WATCH_SYSTEM_PMU = 3;
  HEALTH_WATCH_SYSTEM_MCU = 4;
  HEALTH_WATCH_SYSTEM_MEM = 5;
  HEALTH_WATCH_SYSTEM_SM = 6;
  HEALTH_WATCH_SYSTEM_INFOROM = 7;
  HEALTH_WATCH_SYSTEM_THERMAL = 8;
  HEALTH_WATCH_SYSTEM_POWER = 9;
  HEALTH_WATCH_SYSTEM_DRIVER = 10;
  HEALTH_WATCH_SYSTEM_NVSWITCH = 11;
}

// HealthEvent represents a raw GPU health event for CEL policy evaluation.
// Events are collected by the node agent and sent to the control plane
// where CEL policies determine the health classification.
message HealthEvent {
  // When the event occurred.
  google.protobuf.Timestamp timestamp = 1;

  // GPU index that reported the event (-1 for node-level events).
  int32 gpu_index = 2;

  // GPU UUID (empty for node-level events).
  string gpu_uuid = 3;

  // DCGM health watch system that generated the event.
  HealthWatchSystem system = 4;

  // Type of health event.
  HealthEventType event_type = 5;

  // Event-specific metrics for CEL policy evaluation.
  // Common keys: xid_code (int), temperature (int), power_watts (double),
  // ecc_sbe_count (int), ecc_dbe_count (int), link_id (int).
  map<string, string> metrics = 6;

  // Human-readable description of the event.
  string message = 7;
}

// NodeStatus represents the overall state of a node in the fleet.
enum NodeStatus {
  // Unknown or uninitialized status.
  NODE_STATUS_UNKNOWN = 0;

  // Node is healthy and accepting workloads.
  NODE_STATUS_ACTIVE = 1;

  // Node is not accepting new workloads (administrative action).
  NODE_STATUS_CORDONED = 2;

  // Node is waiting for existing workloads to complete before termination.
  NODE_STATUS_DRAINING = 3;

  // Node has failed health checks and should be replaced.
  NODE_STATUS_UNHEALTHY = 4;

  // Node is scheduled for termination.
  NODE_STATUS_TERMINATED = 5;
}

// InstanceState represents the lifecycle state of a cloud instance.
// Instances are tracked separately from nodes to capture the full lifecycle
// from provisioning through termination, including cases where nodes fail
// to register or boot properly.
enum InstanceState {
  // Unknown or uninitialized state.
  INSTANCE_STATE_UNKNOWN = 0;

  // Instance is being provisioned by the cloud provider.
  // Entered when: provider.Provision() is called.
  INSTANCE_STATE_PROVISIONING = 1;

  // Instance has been provisioned and is waiting for the node agent to register.
  // Entered when: provider.Provision() returns successfully.
  // Expected duration: typically 1-5 minutes depending on instance type.
  INSTANCE_STATE_PENDING_REGISTRATION = 2;

  // Instance is running and the node agent has registered successfully.
  // Entered when: RegisterNode is called with matching instance ID.
  INSTANCE_STATE_RUNNING = 3;

  // Instance is being terminated.
  // Entered when: termination is requested via ScaleDown or explicit termination.
  INSTANCE_STATE_TERMINATING = 4;

  // Instance has been terminated.
  // Entered when: provider.Terminate() completes successfully.
  INSTANCE_STATE_TERMINATED = 5;

  // Instance provisioning or registration failed.
  // Entered when: provisioning fails, or registration timeout expires.
  INSTANCE_STATE_FAILED = 6;
}

// InstanceInfo describes a cloud instance tracked by the control plane.
// This represents the cloud resource itself, independent of whether a node
// agent is running on it. Use this to track costs, detect stuck instances,
// and manage the full instance lifecycle.
message InstanceInfo {
  // Provider-assigned instance ID (e.g., GCP instance name, AWS instance ID).
  string instance_id = 1;

  // Cloud provider name (e.g., "gcp", "aws", "lambda").
  string provider = 2;

  // Cloud region where the instance is running.
  string region = 3;

  // Availability zone within the region.
  string zone = 4;

  // Instance type (e.g., "a3-highgpu-8g", "p5.48xlarge").
  string instance_type = 5;

  // Current lifecycle state of the instance.
  InstanceState state = 6;

  // Name of the pool that provisioned this instance (empty if standalone).
  string pool_name = 7;

  // When the instance was requested (provisioning started).
  google.protobuf.Timestamp created_at = 8;

  // When the instance became ready (node registered), if applicable.
  google.protobuf.Timestamp ready_at = 9;

  // When the instance was terminated, if applicable.
  google.protobuf.Timestamp terminated_at = 10;

  // ID of the registered node, if the node has registered.
  // Empty if the instance is still pending registration or failed.
  string node_id = 11;

  // Human-readable status message (e.g., error details for failed instances).
  string status_message = 12;

  // User-defined labels copied from the pool configuration.
  map<string, string> labels = 13;
}

// HeartbeatRequest is a periodic keepalive message from a node.
message HeartbeatRequest {
  // ID of the node sending the heartbeat.
  string node_id = 1;

  // Timestamp when heartbeat was sent.
  google.protobuf.Timestamp timestamp = 2;

  // Optional basic metrics (lightweight, doesn't require health checks).
  NodeMetrics metrics = 3;
}

// HeartbeatResponse acknowledges receipt of heartbeat.
message HeartbeatResponse {
  // Whether heartbeat was received successfully.
  bool acknowledged = 1;
}

message NodeMetrics {
  // CPU usage percentage (0-100).
  double cpu_usage_percent = 1;

  // Memory usage percentage (0-100).
  double memory_usage_percent = 2;

  // Per-GPU metrics.
  repeated GPUMetrics gpu_metrics = 3;
}

message GPUMetrics {
  // GPU index (0-based).
  int32 gpu_index = 1;

  // GPU temperature in Celsius.
  int32 temperature = 2;

  // Current power usage in watts.
  int32 power_usage = 3;

  // GPU utilization percentage (0-100).
  double utilization_percent = 4;

  // GPU memory used in bytes.
  int64 memory_used = 5;
}

// GetNodeCommandsRequest polls for pending commands.
message GetNodeCommandsRequest {
  // ID of the node requesting commands.
  string node_id = 1;
}

// GetNodeCommandsResponse contains commands for the node to execute.
message GetNodeCommandsResponse {
  // List of commands to execute (empty if no pending commands).
  repeated NodeCommand commands = 1;
}

message NodeCommand {
  // Unique identifier for this command (used for acknowledgment).
  string command_id = 1;

  // Type of command to execute.
  NodeCommandType type = 2;

  // Command-specific parameters.
  map<string, string> parameters = 3;

  // When the command was issued.
  google.protobuf.Timestamp issued_at = 4;
}

// NodeCommandType specifies the action a node should take.
enum NodeCommandType {
  // Unknown or uninitialized command type.
  NODE_COMMAND_TYPE_UNKNOWN = 0;

  // Stop accepting new workloads but keep running existing ones.
  NODE_COMMAND_TYPE_CORDON = 1;

  // Drain existing workloads gracefully.
  NODE_COMMAND_TYPE_DRAIN = 2;

  // Run a specific diagnostic test.
  NODE_COMMAND_TYPE_RUN_DIAGNOSTIC = 3;

  // Prepare for node shutdown/termination.
  NODE_COMMAND_TYPE_TERMINATE = 4;
}

// Admin API messages

message ListNodesRequest {
  // Optional filter by provider.
  string provider = 1;

  // Optional filter by region.
  string region = 2;

  // Optional filter by status.
  NodeStatus status = 3;
}

message ListNodesResponse {
  repeated NodeInfo nodes = 1;
}

message NodeInfo {
  string node_id = 1;
  string provider = 2;
  string region = 3;
  string zone = 4;
  string instance_type = 5;
  NodeStatus status = 6;
  HealthStatus health_status = 7;
  google.protobuf.Timestamp last_heartbeat = 8;
  repeated GPUInfo gpus = 9;
  NodeMetadata metadata = 10;
}

message GetNodeRequest {
  string node_id = 1;
}

message GetNodeResponse {
  NodeInfo node = 1;
}

message IssueCommandRequest {
  string node_id = 1;
  NodeCommandType command_type = 2;
  map<string, string> parameters = 3;
}

message IssueCommandResponse {
  string command_id = 1;
  google.protobuf.Timestamp issued_at = 2;
}

// Instance tracking messages

message ListInstancesRequest {
  // Optional filter by provider.
  string provider = 1;

  // Optional filter by region.
  string region = 2;

  // Optional filter by state.
  InstanceState state = 3;

  // Optional filter by pool name.
  string pool_name = 4;
}

message ListInstancesResponse {
  repeated InstanceInfo instances = 1;
}

message GetInstanceRequest {
  string instance_id = 1;
}

message GetInstanceResponse {
  InstanceInfo instance = 1;
}
